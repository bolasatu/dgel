# Architecture: WGSL Shader Packaging & WebGPU Pipeline

This document describes how the WGSL shader code is generated, packaged, and integrated into the WebGPU rendering pipeline within this engine.

## Overview

The engine abstracts the raw WebGPU API to provide a more declarative way to define pipelines and shaders. The core concept is that shaders are not just static text files; they are dynamically assembled from various components:

1.  **User-provided WGSL code**: The core logic of the vertex and fragment shaders.
2.  **Generated Header Code**: Struct definitions, uniform buffer declarations, and input/output structural definitions derived from JavaScript/TypeScript objects.
3.  **Pipeline Configuration**: The `Pipeline` class orchestrates the creation of the `GPURenderPipeline` (or `GPUComputePipeline`), linking bind groups, attributes, and shaders.

## Core Classes

### 1. `Pipeline` (`src/core/Pipeline.ts`)
The `Pipeline` class is the high-level interface. It accepts a configuration object (`PipelineOptions`) defining:
-   `bindGroupLayouts`: Layouts for uniforms and resources.
-   `ins`: Vertex attributes (inputs to vertex shader).
-   `outs`: Outputs from vertex shader / inputs to fragment shader.
-   `vertex` / `fragment` / `compute`: The main WGSL code for each stage.
-   `structs`: Custom structs used in the shader.

It is responsible for:
-   Initializing the `Program`.
-   Creating the WebGPU `GPUPipelineLayout`.
-   Creating the `GPURenderPipeline` or `GPUComputePipeline`.

### 2. `Program` (`src/core/Program.ts`)
The `Program` class acts as a bridge between the pipeline configuration and the shaders. It manages:
-   **Header Generation**: It iterates over `BindGroupLayouts` to generate the necessary WGSL (or GLSL) code for Uniform Buffers, Storage Buffers, Textures, and Samplers.
-   **Shader Initialization**: It instantiates `Shader` objects for each stage (vertex, fragment, compute) and injects the generated headers.

### 3. `Shader` (`src/core/Shader.ts`)
The `Shader` class encapsulates a single shader stage. It assembles the final shader source code by concatenating:
-   **Struct Definitions**: Generated from `Struct` objects.
-   **Uniform Headers**: Generated by `Program`.
-   **Inputs/Outputs**: `Attribute` and `BuiltIn` definitions are converted to WGSL struct members or parameters.
-   **Body**: Common code or helper functions.
-   **Main Function**: The user-provided logic wrapped in a `main` function with appropriate signature.

It then compiles the shader using `device.createShaderModule`.

### 4. `BindGroupLayout` & `BindGroup` (`src/core/BindGroupLayout.ts`, `src/core/BindGroup.ts`)
-   `BindGroupLayout` defines the interface of the shader (what resources it expects). It calculates buffer sizes and generates the layout descriptor for WebGPU.
-   `BindGroup` binds actual WebGPU resources (Buffers, Textures, Samplers) to the layout.

## Shader Packaging Process

When `pipeline.init()` is called, the following steps occur:

1.  **Attribute Mapping**: The `ins` (input attributes) are processed to create the `GPUVertexBufferLayout`.
2.  **Header Generation**:
    -   `Program` traverses the `bindGroupLayouts`.
    -   For each entry (Uniform Buffer, Texture, Sampler), it generates the corresponding WGSL declaration (e.g., `@group(0) @binding(0) var<uniform> ...`).
    -   Structs for uniform buffers are generated based on `Uniform` definitions.
3.  **Shader Assembly**:
    -   `Shader.init()` is called with the generated headers.
    -   It creates the `Output` struct (for vertex output / fragment input) based on `outs`.
    -   It constructs the `main` function signature, injecting inputs as arguments.
    -   It combines everything into a single string:
        ```wgsl
        // Structs
        struct MyUniforms { ... };

        // Uniforms / Bindings
        @group(0) @binding(0) var<uniform> myUniforms : MyUniforms;

        // Outputs
        struct Output { ... };

        // Body (Helper functions)
        ...

        // Main
        @vertex
        fn main(
          @location(0) position: vec3<f32>, ...
        ) -> Output {
           // User code
        }
        ```
4.  **Module Creation**: The assembled WGSL string is passed to `device.createShaderModule`.

## Example Flow

In `examples/cube.js`:

1.  **Layouts**: `systemBindGroupLayout` (projection/view matrices) and `meshBindGroupLayout` (model matrix, texture) are defined.
2.  **Pipeline**:
    ```javascript
    const pipeline = new Pipeline({
      bindGroupLayouts: [systemBindGroupLayout, meshBindGroupLayout],
      ins: [ ...Attributes... ],
      outs: [ ...Outputs... ],
      vertex: /* wgsl code */,
      fragment: /* wgsl code */
    });
    ```
3.  **Execution**:
    -   The `Program` generates WGSL declarations for `system` and `mesh` uniform structs.
    -   It generates bindings `@group(0) @binding(0) var<uniform> system ...` and `@group(1) @binding(0) var<uniform> mesh ...`.
    -   The `vertex` string is inserted into the main function.
    -   The `pipeline` object now holds the `gpuPipeline` ready for rendering commands.
